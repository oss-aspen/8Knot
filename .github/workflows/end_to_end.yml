name: Test Docker images
on:
  push:
    branches:
      - main
      - release
  pull_request:
  release:
    types:
      - published
  workflow_dispatch:

permissions: {}

jobs:
  test-e2e-podman:
    name: End-to-end test (Podman)
    runs-on: ubuntu-latest
    steps:
      - name: Remove unnecessary files from the base image
        run: |
          sudo rm -rf /usr/share/dotnet
          sudo rm -rf "$AGENT_TOOLSDIRECTORY"

      - name: Start Podman socket
        run: systemctl --user start podman.socket

      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Build 8knot container
        uses: redhat-actions/buildah-build@v2
        with:
          context: .
          containerfiles: |
            ./docker/Dockerfile
          platforms: linux/amd64
          # ghcr.io/${{ github.repository_owner }}/
          tags: 8knot-app:test
          layers: true

      - name: Prepare env file
        run: |
          cp .env.sample .env

      - name: Prepare compose file
        run: |
          yq eval -i '.services.db-init.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.db-init.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.db-init.restart = "no"' docker-compose.yml

          yq eval -i '.services.app-server.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.app-server.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.app-server.restart = "no"' docker-compose.yml
          yq eval -i '.services.app-server.healthcheck.test = "curl -f http://localhost:8080/ || exit 1"' docker-compose.yml
          yq eval -i '.services.app-server.healthcheck.interval = "15s"' docker-compose.yml
          yq eval -i '.services.app-server.healthcheck.timeout = "2m"' docker-compose.yml

          yq eval -i '.services.worker-callback.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.worker-callback.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.worker-callback.restart = "no"' docker-compose.yml

          yq eval -i '.services.worker-query.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.worker-query.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.worker-query.restart = "no"' docker-compose.yml

          yq eval -i '.services.mock-db.image = "ghcr.io/chaoss/augur_empty_database:latest"' docker-compose.yml

      - name: Setup Podman Compose
        uses: webgtx/setup-podman-compose@v1

      - name: Set up list of log lines to match
        run: |
          cat <<EOF > /tmp/regex_matches.txt
          Ready to accept connections
          database system is ready to accept connections
          Database connection established successfully!
          ALL TABLES COMMITTED SUCCESSFULLY
          POSTGRES CACHE SUCCESSFULLY INITIALIZED
          AUGUR: Connection to DB succeeded
          Listening at: http://0.0.0.0:8080
          Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
          /docker-entrypoint.sh: Configuration complete; ready for start up
          EOF

      - name: Start services & wait for output
        # This starts the system and sends the output to "await_all.py" which
        # scans for the regex matches from above. Once all matches are seen at
        # least once, the `compose down` will run to shut down the system. If
        # this all doesn't happen before the timeout, the job will fail.
        run: |
          podman compose -f docker-compose.yml up --no-build 2>&1 \
            | (./scripts/ci/await_all.py /tmp/regex_matches.txt \
                && podman compose -f docker-compose.yml down)
        timeout-minutes: 3

      - name: Dump logs
        # Always run this step to get logs, even if the previous step fails
        if: always()
        # We use tail so that we can see the name of each file as it's printed
        run: "podman run -t --rm -v augur_logs:/logs bash -c 'find /logs -type f | xargs tail -n +0'"

  test-e2e-docker:
    name: End-to-end test (Docker)
    runs-on: ubuntu-latest
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3
        id: setup-buildx

      - name: Build 8knot container
        uses: docker/build-push-action@v6
        with:
          context: .
          file: ./docker/Dockerfile
          platforms: linux/amd64
          tags: 8knot-app:test
          cache-from: type=gha,scope=container-database
          cache-to: type=gha,scope=container-database,mode=min
          load: true

      - name: Prepare env file
        run: |
          cp .env.sample .env

      - name: Prepare compose file
        run: |
          yq eval -i '.services.db-init.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.db-init.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.db-init.restart = "no"' docker-compose.yml

          yq eval -i '.services.app-server.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.app-server.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.app-server.restart = "no"' docker-compose.yml
          yq eval -i '.services.app-server.healthcheck.test = "curl -f http://localhost:8080/ || exit 1"' docker-compose.yml
          yq eval -i '.services.app-server.healthcheck.interval = "15s"' docker-compose.yml
          yq eval -i '.services.app-server.healthcheck.timeout = "2m"' docker-compose.yml

          yq eval -i '.services.worker-callback.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.worker-callback.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.worker-callback.restart = "no"' docker-compose.yml

          yq eval -i '.services.worker-query.image = "8knot-app:test"' docker-compose.yml
          yq eval -i '.services.worker-query.pull_policy = "never"' docker-compose.yml
          yq eval -i '.services.worker-query.restart = "no"' docker-compose.yml

          yq eval -i '.services.mock-db.image = "ghcr.io/chaoss/augur_empty_database:latest"' docker-compose.yml


      - name: Setup Docker Compose
        uses: docker/setup-compose-action@v1
        with:
          version: latest

      - name: Set up list of log lines to match
        run: |
          cat <<EOF > /tmp/regex_matches.txt
          Ready to accept connections
          database system is ready to accept connections
          Database connection established successfully!
          ALL TABLES COMMITTED SUCCESSFULLY
          POSTGRES CACHE SUCCESSFULLY INITIALIZED
          AUGUR: Connection to DB succeeded
          Listening at: http://0.0.0.0:8080
          Enabled listen on IPv6 in /etc/nginx/conf.d/default.conf
          /docker-entrypoint.sh: Configuration complete; ready for start up
          EOF

      - name: Start services & wait for output
        # This starts the system and sends the output to "await_all.py" which
        # scans for the regex matches from above. Once all matches are seen at
        # least once, the `compose down` will run to shut down the system. If
        # this all doesn't happen before the timeout, the job will fail.
        run: |
          docker compose -f docker-compose.yml up --no-build 2>&1 \
            | (./scripts/ci/await_all.py /tmp/regex_matches.txt \
                && docker compose -f docker-compose.yml down)
        timeout-minutes: 3


      - name: Dump logs
        # Always run this step to get logs, even if the previous step fails
        if: always()
        # We use tail so that we can see the name of each file as it's printed
        run: "docker run -t --rm -v augur_logs:/logs bash -c 'find /logs -type f | xargs tail -n +0'"
